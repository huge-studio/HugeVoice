// libsamplerate.js - Minimal implementation for HugeVoice
// Based on Secret Rabbit Code (libsamplerate) algorithms
// This is a simplified version for basic sample rate conversion

(function(global) {
    'use strict';

    // Converter types
    const SRC_SINC_BEST_QUALITY = 0;
    const SRC_SINC_MEDIUM_QUALITY = 1;
    const SRC_SINC_FASTEST = 2;
    const SRC_ZERO_ORDER_HOLD = 3;
    const SRC_LINEAR = 4;

    // Simple linear interpolation resampler
    function linearResample(inputData, inputRate, outputRate) {
        const ratio = inputRate / outputRate;
        const outputLength = Math.round(inputData.length / ratio);
        const output = new Float32Array(outputLength);

        for (let i = 0; i < outputLength; i++) {
            const srcIndex = i * ratio;
            const srcIndexFloor = Math.floor(srcIndex);
            const srcIndexCeil = Math.min(srcIndexFloor + 1, inputData.length - 1);
            const fraction = srcIndex - srcIndexFloor;

            // Linear interpolation
            output[i] = inputData[srcIndexFloor] * (1 - fraction) + inputData[srcIndexCeil] * fraction;
        }

        return output;
    }

    // Sinc interpolation resampler (high quality)
    function sincResample(inputData, inputRate, outputRate, quality) {
        // For simplicity, use windowed sinc interpolation
        const ratio = inputRate / outputRate;
        const outputLength = Math.round(inputData.length / ratio);
        const output = new Float32Array(outputLength);

        // Filter width based on quality
        let filterWidth;
        switch (quality) {
            case SRC_SINC_BEST_QUALITY:
                filterWidth = 128;
                break;
            case SRC_SINC_MEDIUM_QUALITY:
                filterWidth = 64;
                break;
            case SRC_SINC_FASTEST:
                filterWidth = 16;
                break;
            default:
                filterWidth = 64;
        }

        const halfFilterWidth = filterWidth / 2;

        for (let i = 0; i < outputLength; i++) {
            const srcIndex = i * ratio;
            let sum = 0;
            let weightSum = 0;

            for (let j = -halfFilterWidth; j < halfFilterWidth; j++) {
                const sampleIndex = Math.floor(srcIndex) + j;
                
                if (sampleIndex >= 0 && sampleIndex < inputData.length) {
                    const offset = srcIndex - sampleIndex;
                    
                    // Sinc function with Blackman window
                    let weight;
                    if (Math.abs(offset) < 0.0001) {
                        weight = 1.0;
                    } else {
                        const sincValue = Math.sin(Math.PI * offset) / (Math.PI * offset);
                        const windowValue = 0.42 - 0.5 * Math.cos(2 * Math.PI * (j + halfFilterWidth) / filterWidth) + 
                                           0.08 * Math.cos(4 * Math.PI * (j + halfFilterWidth) / filterWidth);
                        weight = sincValue * windowValue;
                    }

                    sum += inputData[sampleIndex] * weight;
                    weightSum += weight;
                }
            }

            output[i] = weightSum > 0 ? sum / weightSum : 0;
        }

        return output;
    }

    // Main resampling function
    function simple(inputData, inputRate, outputRate, options) {
        options = options || {};
        const converterType = options.converterType !== undefined ? options.converterType : SRC_SINC_MEDIUM_QUALITY;

        // If rates are the same, return copy
        if (Math.abs(inputRate - outputRate) < 1) {
            return new Float32Array(inputData);
        }

        // Choose resampling method based on converter type
        switch (converterType) {
            case SRC_SINC_BEST_QUALITY:
            case SRC_SINC_MEDIUM_QUALITY:
            case SRC_SINC_FASTEST:
                return sincResample(inputData, inputRate, outputRate, converterType);
            
            case SRC_LINEAR:
                return linearResample(inputData, inputRate, outputRate);
            
            case SRC_ZERO_ORDER_HOLD:
                // Nearest neighbor (zero-order hold)
                const ratio = inputRate / outputRate;
                const outputLength = Math.round(inputData.length / ratio);
                const output = new Float32Array(outputLength);
                for (let i = 0; i < outputLength; i++) {
                    const srcIndex = Math.round(i * ratio);
                    output[i] = inputData[Math.min(srcIndex, inputData.length - 1)];
                }
                return output;
            
            default:
                return linearResample(inputData, inputRate, outputRate);
        }
    }

    // Create resampler object (for streaming)
    function create(channels, inputRate, outputRate, options) {
        return {
            channels: channels,
            inputRate: inputRate,
            outputRate: outputRate,
            options: options || {},
            destroy: function() {
                // Cleanup if needed
            }
        };
    }

    // Export LibSampleRate API
    const LibSampleRate = {
        SRC_SINC_BEST_QUALITY: SRC_SINC_BEST_QUALITY,
        SRC_SINC_MEDIUM_QUALITY: SRC_SINC_MEDIUM_QUALITY,
        SRC_SINC_FASTEST: SRC_SINC_FASTEST,
        SRC_ZERO_ORDER_HOLD: SRC_ZERO_ORDER_HOLD,
        SRC_LINEAR: SRC_LINEAR,
        simple: simple,
        create: create
    };

    // Make it globally available
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = LibSampleRate;
    } else {
        global.LibSampleRate = LibSampleRate;
    }

})(typeof window !== 'undefined' ? window : this);
